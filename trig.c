
/* SPDX-License-Identifier: MIT */
/*
 * trig.c
 *
 * Initial implementations of trigonometric functions using long doubles.
 * Written to test the CORDIC algorithm implementation,
 * before tailoring it for fxp's
 *
 * By Raul Saavedra, Bonn Germany
 */

#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <math.h>
#include "fxp_extern.h"

#define DASHES "=========================================\n"

const long double CORDIC_KSCALE = 0.607252935008881256169446752504929L;

// tangent values of angles to use for CORDIC,
// all tangents being negative powers of 2:
// TANGENT[i] = 1/(2^(-i)), with i from 0 to 31
static const long double TANGENT[] = {
1.000000000000000000000000000000000L,   // [0]
0.500000000000000000000000000000000L,
0.250000000000000000000000000000000L,
0.125000000000000000000000000000000L,
0.062500000000000000000000000000000L,
0.031250000000000000000000000000000L,
0.015625000000000000000000000000000L,
0.007812500000000000000000000000000L,
0.003906250000000000000000000000000L,
0.001953125000000000000000000000000L,
0.000976562500000000000000000000000L,   // [10]
0.000488281250000000000000000000000L,
0.000244140625000000000000000000000L,
0.000122070312500000000000000000000L,
0.000061035156250000000000000000000L,
0.000030517578125000000000000000000L,
0.000015258789062500000000000000000L,
0.000007629394531250000000000000000L,
0.000003814697265625000000000000000L,
0.000001907348632812500000000000000L,
0.000000953674316406250000000000000L,   // [20]
0.000000476837158203125000000000000L,
0.000000238418579101562500000000000L,
0.000000119209289550781250000000000L,
0.000000059604644775390625000000000L,
0.000000029802322387695312500000000L,
0.000000014901161193847656250000000L,
0.000000007450580596923828125000000L,
0.000000003725290298461914062500000L,
0.000000001862645149230957031250000L,
0.000000000931322574615478515625000L,   // [30]
0.000000000465661287307739257812500L,   // [31]
0.000000000232830643653869628906250L,
0.000000000116415321826934814453125L,
0.000000000058207660913467407226562L,
0.000000000029103830456733703613281L,
0.000000000014551915228366851806641L
/*
0.000000000007275957614183425903320L,   // [37] From here on, TANGENT[i] == ANGLE[i]
0.000000000003637978807091712951660L,   // (using precision of 33 decimal frac digits == 112 frac bits)
0.000000000001818989403545856475830L,
0.000000000000909494701772928237915L,   // [40]
0.000000000000454747350886464118958L,
0.000000000000227373675443232059479L,
0.000000000000113686837721616029739L,
0.000000000000056843418860808014870L,
0.000000000000028421709430404007435L,
0.000000000000014210854715202003717L,
0.000000000000007105427357601001859L,
0.000000000000003552713678800500929L,
0.000000000000001776356839400250465L,
0.000000000000000888178419700125232L,   // [50]
0.000000000000000444089209850062616L,
0.000000000000000222044604925031308L,
0.000000000000000111022302462515654L,
0.000000000000000055511151231257827L,
0.000000000000000027755575615628914L,
0.000000000000000013877787807814457L,
0.000000000000000006938893903907228L,
0.000000000000000003469446951953614L,
0.000000000000000001734723475976807L,
0.000000000000000000867361737988404L,   // [60]
0.000000000000000000433680868994202L,
0.000000000000000000216840434497101L,
0.000000000000000000108420217248550L,   // [63]
0.000000000000000000054210108624275L    // [64]
*/
};

// ANGLE[n] = atanl(TANGENT[n]), with n from 0 to 64
// These angles all in radians, 1st element is pi/4
static const long double ANGLE[] = {
0.785398163397448309615660845819876L,    // [0]
0.463647609000806116214256231461214L,
0.244978663126864154172082481211276L,
0.124354994546761435031354849163871L,
0.062418809995957348473979112985505L,
0.031239833430268276253711744892491L,
0.015623728620476830802801521256570L,
0.007812341060101111296463391842199L,
0.003906230131966971827628665311424L,
0.001953122516478818685121482625077L,
0.000976562189559319430403430199717L,    // [10]
0.000488281211194898275469239625645L,
0.000244140620149361764016722943260L,
0.000122070311893670204239058646118L,
0.000061035156174208775021662569174L,
0.000030517578115526096861825953439L,
0.000015258789061315762107231935813L,
0.000007629394531101970263388482340L,
0.000003814697265606496282923075616L,
0.000001907348632810187035365369306L,
0.000000953674316405960879420670690L,    // [20]
0.000000476837158203088859927583821L,
0.000000238418579101557982490947977L,
0.000000119209289550780685311368497L,
0.000000059604644775390554413921062L,
0.000000029802322387695303676740133L,
0.000000014901161193847655147092517L,
0.000000007450580596923827987136565L,
0.000000003725290298461914045267071L,
0.000000001862645149230957029095884L,
0.000000000931322574615478515355735L,   // [30]
0.000000000465661287307739257778842L,   // [31]
0.000000000232830643653869628902043L,   // [32]
0.000000000116415321826934814452599L,   // [33]
0.000000000058207660913467407226497L,   // [34]
0.000000000029103830456733703613273L,   // [35]
0.000000000014551915228366851806640L,   // [36]
0.000000000007275957614183425903320L,   // [37] From here on, TANGENT[i] == ANGLE[i]
0.000000000003637978807091712951660L,   // (using precision of 33 decimal frac digits == 112 frac bits)
0.000000000001818989403545856475830L,
0.000000000000909494701772928237915L,   // [40]
0.000000000000454747350886464118958L,
0.000000000000227373675443232059479L,
0.000000000000113686837721616029739L,
0.000000000000056843418860808014870L,
0.000000000000028421709430404007435L,
0.000000000000014210854715202003717L,
0.000000000000007105427357601001859L,
0.000000000000003552713678800500929L,
0.000000000000001776356839400250465L,
0.000000000000000888178419700125232L,   // [50]
0.000000000000000444089209850062616L,
0.000000000000000222044604925031308L,
0.000000000000000111022302462515654L,
0.000000000000000055511151231257827L,
0.000000000000000027755575615628914L,
0.000000000000000013877787807814457L,
0.000000000000000006938893903907228L,
0.000000000000000003469446951953614L,
0.000000000000000001734723475976807L,
0.000000000000000000867361737988404L,   // [60]
0.000000000000000000433680868994202L,
0.000000000000000000216840434497101L,
0.000000000000000000108420217248550L   // [63]
//0.000000000000000000054210108624275L // [64]
};

#define MAX_LOOPS 32

/*
 * Calculates simultaneously the sine and cosine of the argument x
 * using the CORDIC algorithm:
 * https://en.wikibooks.org/wiki/Trigonometry/For_Enthusiasts/The_CORDIC_Algorithm
 */
void my_sincos(long double x, long double *mysin, long double *mycos)
{
        // x should be in [0, pi/2]
        long double a = 0.0L;
        long double c = 1.0L;
        long double s = 0.0L;
        printf("Start: angle is %Lf, c is %Lf, s is %Lf\n", a/M_PI*180.0L, c, s);
        // CORDIC implementation
        for (int i = 0; i < MAX_LOOPS; i++) {
                long double angle = ANGLE[i];
                long double tangent = TANGENT[i];
                if (a < x) {
                        //printf("+ rotation\n");
                        a += angle;
                        // These products would get implemented with simple shifts
                        long double newc = c - s*tangent;
                        s += c*tangent;
                        c = newc;
                } else {
                        //printf("- rotation\n");
                        a -= angle;
                        // These products would get implemented with simple shifts
                        long double newc = c + s*tangent;
                        s -= c*tangent;
                        c = newc;
                }
                printf("Iteration %2d: angle change %Lf, new c is %Lf, new s is %Lf, angle' %14.12Lf\n", \
                            i, angle/M_PI*180.0L, c, s, a/M_PI*180.0L);
        }
        *mycos = c * CORDIC_KSCALE;
        *mysin = s * CORDIC_KSCALE;
        return;
}

int main(void)
{
        printf("\n%sTests the trigonometric functions using long doubles\n%s", DASHES, DASHES);
        printf("K scaling factor for Cordic: %35.33Lf\n", CORDIC_KSCALE);

        long double angle = 55.0L/180.0L*M_PI;
        long double s = sinl(angle);
        long double c = cosl(angle);
        long double mysine = 0.0L, mycos = 0.0L;
        my_sincos(angle, &mysine, &mycos);
        printf("clib sin(%Lf) = %35.33Lf\n", angle, s);
        printf("my   sin(%Lf) = %35.33Lf\n", angle, mysine);
        printf("clib cos(%Lf) = %35.33Lf\n", angle, c);
        printf("my   cos(%Lf) = %35.33Lf\n", angle, mycos);
}
